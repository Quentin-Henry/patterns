<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grid Architecture - Streamlined v4</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display",
          "Helvetica Neue", sans-serif;
        background: #fafbfc;
        height: 100vh;
        display: flex;
        overflow: hidden;
        color: #1a1a1a;
      }

      .controls {
        width: 340px;
        background: #ffffff;
        border-right: 1px solid #e8eaed;
        overflow-y: auto;
        z-index: 10;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.04);
        position: relative;
      }

      .controls.collapsed {
        transform: translateX(-100%);
      }

      .header {
        padding: 24px 24px 20px 24px;
        border-bottom: 1px solid #f1f3f4;
        background: #ffffff;
      }

      .logo-area {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .logo-placeholder {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        background: linear-gradient(135deg, #0956ff, #667eea);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 14px;
      }

      .title-group {
        flex: 1;
      }

      .app-title {
        font-size: 18px;
        font-weight: 600;
        color: #1a1a1a;
        line-height: 1.2;
        margin-bottom: 2px;
      }

      .app-subtitle {
        font-size: 12px;
        color: #5f6368;
        font-weight: 400;
        line-height: 1.3;
      }

      .toggle-btn {
        position: absolute;
        right: -48px;
        top: 24px;
        width: 40px;
        height: 40px;
        background: #ffffff;
        border: 1px solid #e8eaed;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .toggle-btn:hover {
        background: #f8f9fa;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      }

      .controls-content {
        padding: 0 24px 24px 24px;
      }

      .control-section {
        margin-bottom: 32px;
      }

      .control-section:last-child {
        margin-bottom: 0;
      }

      .section-title {
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 16px;
        color: #3c4043;
        letter-spacing: -0.01em;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .section-icon {
        width: 16px;
        height: 16px;
        opacity: 0.6;
      }

      .control-item {
        margin-bottom: 20px;
      }

      .control-item:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: block;
        font-size: 12px;
        color: #5f6368;
        margin-bottom: 8px;
        font-weight: 500;
        letter-spacing: -0.01em;
      }

      .control-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      input[type="range"] {
        flex: 1;
        height: 2px;
        background: #e8eaed;
        border-radius: 1px;
        outline: none;
        -webkit-appearance: none;
        cursor: pointer;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        background: #0956ff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(25, 118, 210, 0.3);
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        background: #0956ff;
        transform: scale(1.1);
        box-shadow: 0 3px 8px rgba(25, 118, 210, 0.4);
      }

      .value-display {
        font-size: 12px;
        color: #5f6368;
        width: 32px;
        text-align: right;
        font-weight: 500;
        font-variant-numeric: tabular-nums;
      }

      .button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 8px;
      }

      .button-grid.three-col {
        grid-template-columns: 1fr 1fr 1fr;
      }

      .option-btn {
        padding: 10px 12px;
        border: 1px solid #e8eaed;
        border-radius: 6px;
        background: #ffffff;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
        font-weight: 500;
        color: #3c4043;
        letter-spacing: -0.01em;
      }

      .option-btn:hover {
        background: #f8f9fa;
        border-color: #dadce0;
      }

      .option-btn.active {
        background: #0956ff;
        color: #ffffff;
        border-color: #0956ff;
        box-shadow: 0 2px 4px rgba(25, 118, 210, 0.2);
      }

      .primary-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 20px;
      }

      .primary-btn {
        padding: 12px 16px;
        border: 1px solid #e8eaed;
        border-radius: 8px;
        background: #ffffff;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
        font-weight: 500;
        color: #3c4043;
        letter-spacing: -0.01em;
      }

      .primary-btn:hover {
        background: #f8f9fa;
        border-color: #dadce0;
      }

      .primary-btn.active {
        background: #0956ff;
        color: #ffffff;
        border-color: #0956ff;
        box-shadow: 0 2px 6px rgba(25, 118, 210, 0.24);
      }

      .canvas-container {
        flex: 1;
        background: #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      #canvas {
        background: #ffffff;
        display: block;
        border-radius: 0;
        box-shadow: none;
      }

      .export-btn {
        width: 100%;
        padding: 12px 16px;
        background: #0956ff;
        color: #ffffff;
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        letter-spacing: -0.01em;
        margin-top: 24px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .export-btn:hover {
        background: #0956ff;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
      }

      .stats {
        background: #f8f9fa;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 11px;
        color: #5f6368;
        margin-top: 20px;
        border: 1px solid #f1f3f4;
        line-height: 1.4;
        font-weight: 400;
        font-variant-numeric: tabular-nums;
      }

      .status-indicator {
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 6px;
        padding: 8px 12px;
        margin: 12px 0;
        font-size: 11px;
        color: #0956ff;
        text-align: center;
        font-weight: 500;
        letter-spacing: -0.01em;
      }

      .status-indicator.flowing {
        background: #e8f5e8;
        border-color: #c8e6c9;
        color: #2e7d32;
      }

      .section-divider {
        height: 1px;
        background: linear-gradient(
          90deg,
          transparent 0%,
          #e8eaed 20%,
          #e8eaed 80%,
          transparent 100%
        );
        margin: 24px 0;
      }

      /* Color Palette Styles */
      .color-palette-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin-top: 8px;
      }

      .palette-option {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 12px;
        border: 1px solid #e8eaed;
        border-radius: 6px;
        background: #ffffff;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        font-size: 12px;
        font-weight: 500;
        color: #3c4043;
        letter-spacing: -0.01em;
      }

      .palette-option:hover {
        background: #f8f9fa;
        border-color: #dadce0;
      }

      .palette-option.active {
        background: #f8f9fa;
        border-color: #0956ff;
        box-shadow: 0 2px 4px rgba(25, 118, 210, 0.1);
      }

      .color-swatch {
        display: flex;
        gap: 4px;
      }

      .swatch-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .palette-name {
        flex: 1;
        text-align: left;
      }

      .linked-control {
        background: #f8f9fa;
        border: 1px solid #e8eaed;
        border-radius: 6px;
        padding: 12px;
        margin-top: 8px;
      }

      .linked-control .control-label {
        margin-bottom: 4px;
        font-size: 11px;
        color: #5f6368;
      }
    </style>
  </head>
  <body>
    <div class="controls" id="controls">
      <div class="toggle-btn" id="toggleBtn" title="Toggle Controls">
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="#5f6368"
          stroke-width="2"
        >
          <polyline points="15,18 9,12 15,6"></polyline>
        </svg>
      </div>

      <div class="header">
        <div class="logo-area">
          <div class="logo-placeholder">GM</div>
          <div class="title-group">
            <div class="app-title">Underline Pattern</div>
            <div class="app-subtitle">Kinetic Design System</div>
          </div>
        </div>
      </div>

      <div class="controls-content">
        <!-- MODE SELECTION -->
        <div class="control-section">
          <div class="primary-controls">
            <button class="primary-btn active" id="gridView">
              Blueprint View
            </button>
            <button class="primary-btn" id="cleanView">Production View</button>
          </div>

          <div class="primary-controls">
            <button class="primary-btn active" id="stillMode">
              Static Mode
            </button>
            <button class="primary-btn" id="flowMode">Flow State</button>
          </div>

          <div class="status-indicator" id="statusIndicator">
            Static Blueprint Mode
          </div>
        </div>

        <!-- ENGINEERING SPECS -->
        <div class="control-section">
          <div class="section-title">
            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
            </svg>
            Engineering Specs
          </div>

          <div class="control-item">
            <label class="control-label">Material Palette</label>
            <div class="color-palette-grid">
              <div class="palette-option active" data-palette="ocean">
                <div class="color-swatch">
                  <div class="swatch-color" style="background: #0956ff"></div>
                  <div class="swatch-color" style="background: #ffffff"></div>
                </div>
                <span class="palette-name">GM Blue & White</span>
              </div>

              <div class="palette-option" data-palette="warm">
                <div class="color-swatch">
                  <div class="swatch-color" style="background: #e8e6e3"></div>
                  <div class="swatch-color" style="background: #ffffff"></div>
                </div>
                <span class="palette-name">Warm Gray 100 & White</span>
              </div>

              <div class="palette-option" data-palette="dark">
                <div class="color-swatch">
                  <div class="swatch-color" style="background: #000000"></div>
                  <div class="swatch-color" style="background: #201e1c"></div>
                </div>
                <span class="palette-name">Dark Gray & Black</span>
              </div>

              <div class="palette-option" data-palette="navy">
                <div class="color-swatch">
                  <div class="swatch-color" style="background: #48505e"></div>
                  <div class="swatch-color" style="background: #655e7c"></div>
                </div>
                <span class="palette-name">Cool Gray 500 & 600</span>
              </div>
            </div>
          </div>
        </div>

        <!-- CHASSIS ARCHITECTURE -->
        <div class="control-section">
          <div class="section-title">
            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              <line x1="9" y1="9" x2="15" y2="15"/>
              <line x1="15" y1="9" x2="9" y2="15"/>
            </svg>
            Chassis Architecture
          </div>

          <div class="control-item">
            <label class="control-label">Lane Count</label>
            <div class="control-row">
              <input type="range" id="columns" min="1" max="20" value="1" />
              <span class="value-display" id="columnsValue">1</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Segments per Lane</label>
            <div class="control-row">
              <input type="range" id="baseCells" min="1" max="30" value="2" />
              <span class="value-display" id="baseCellsValue">2</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Frame Width</label>
            <div class="control-row">
              <input type="range" id="frameWidth" min="600" max="1200" value="900" />
              <span class="value-display" id="frameWidthValue">900</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Frame Height</label>
            <div class="control-row">
              <input type="range" id="frameHeight" min="400" max="800" value="600" />
              <span class="value-display" id="frameHeightValue">600</span>
            </div>
          </div>
        </div>

        <!-- DYNAMICS & FLOW -->
        <div class="control-section">
          <div class="section-title">
            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2 2z"/>
              <line x1="8" y1="1" x2="8" y2="6"/>
              <line x1="16" y1="1" x2="16" y2="6"/>
            </svg>
            Dynamics & Flow
          </div>

          <div class="control-item">
            <label class="control-label">Traffic Pattern</label>
            <div class="button-grid three-col">
              <button class="option-btn active" data-movement="standard">
                Static
              </button>
              <button class="option-btn" data-movement="wave">
                Highway
              </button>
              <button class="option-btn" data-movement="pulse">
                Pulse
              </button>
              <button class="option-btn" data-movement="sweep">
                Sweep
              </button>
              <button class="option-btn" data-movement="breath">
                Cruise
              </button>
              <button class="option-btn" data-movement="offset">
                Offset
              </button>
            </div>
          </div>

          <div class="linked-control" id="staticControls" style="display: block;">
            <div class="control-item">
              <label class="control-label">Static Pattern</label>
              <div class="button-grid">
                <button class="option-btn active" data-static="uniform">
                  Uniform
                </button>
                <button class="option-btn" data-static="alternating">
                  Alternating
                </button>
                <button class="option-btn" data-static="cascade">
                  Cascade
                </button>
                <button class="option-btn" data-static="fibonacci">
                  Fibonacci
                </button>
                <button class="option-btn" data-static="golden">
                  Golden
                </button>
                <button class="option-btn" data-static="mirror">
                  Mirror
                </button>
              </div>
            </div>

            <div class="control-item">
              <label class="control-label">Pattern Intensity</label>
              <div class="control-row">
                <input type="range" id="staticIntensity" min="0.1" max="2.0" step="0.1" value="1.0" />
                <span class="value-display" id="staticIntensityValue">1.0</span>
              </div>
            </div>
          </div>

          <div class="linked-control" id="flowControls" style="display: none;">
            <div class="control-item">
              <label class="control-label">Flow Velocity</label>
              <div class="control-row">
                <input type="range" id="flowSpeed" min="0.3" max="2.5" step="0.1" value="1" />
                <span class="value-display" id="flowSpeedValue">1.0</span>
              </div>
            </div>

            <div class="control-item">
                <label class="control-label">Flow Smoothness</label>
                <div class="control-row">
                  <input type="range" id="flowSmoothness" min="0.3" max="3.0" step="0.1" value="1.0" />
                  <span class="value-display" id="flowSmoothnessValue">1.0</span>
                </div>
              </div>

            <div class="control-item">
              <label class="control-label">Response Intensity</label>
              <div class="control-row">
                <input type="range" id="flowIntensity" min="0.3" max="2.0" step="0.1" value="1.0" />
                <span class="value-display" id="flowIntensityValue">1.0</span>
              </div>
            </div>
          </div>
        </div>

       

        <!-- PRECISION RATIOS -->
        <div class="control-section">
          <div class="section-title">
            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="13,2 3,14 12,14 11,22 21,10 12,10"/>
            </svg>
            Precision Ratios
          </div>

          <div class="control-item">
            <label class="control-label">Engineering System</label>
            <div class="button-grid">
              <button class="option-btn" data-ratio="fibonacci">
                Fibonacci
              </button>
              <button class="option-btn" data-ratio="golden">Golden</button>
              <button class="option-btn" data-ratio="harmonic">
                Harmonic
              </button>
              <button class="option-btn active" data-ratio="uniform">Uniform</button>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Tolerance Range</label>
            <div class="control-row">
              <input type="range" id="ratioVariance" min="1.2" max="4.5" step="0.1" value="1" />
              <span class="value-display" id="ratioVarianceValue">1</span>
            </div>
          </div>
        </div>

        <!-- CONNECTION JOINTS -->
        <div class="control-section">
          <div class="section-title">
            <svg class="section-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
              <line x1="8" y1="21" x2="16" y2="21"/>
              <line x1="12" y1="17" x2="12" y2="21"/>
            </svg>
            Connection Joints
          </div>

          <div class="control-item">
            <label class="control-label">Base Thickness</label>
            <div class="control-row">
              <input type="range" id="connectorSize" min="1" max="30" value="12" />
              <span class="value-display" id="connectorSizeValue">12</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Thickness Variance</label>
            <div class="control-row">
              <input type="range" id="weightVariation" min="1.0" max="6.0" step="0.2" value="2.5" />
              <span class="value-display" id="weightVariationValue">2.5</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Dynamic Response</label>
            <div class="button-grid">
              <button class="option-btn active" data-connector="proportional">
                Proportional
              </button>
              <button class="option-btn" data-connector="inverse">
                Inverse
              </button>
              <button class="option-btn" data-connector="fixed">
                Fixed
              </button>
              <button class="option-btn" data-connector="rhythmic">
                Rhythmic
              </button>
            </div>
          </div>
        </div>

        <button class="export-btn" onclick="exportGrid()">
          Export Blueprint
        </button>

        <div class="stats" id="stats">
          Static Blueprint: 3×6 | 900×600 | Fibonacci | GM Blue
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="canvas"></canvas>
    </div>

    <script>
      // ============================================================================
      // STREAMLINED GRID SYSTEM v3.0 - Reorganized and Enhanced
      // ============================================================================

      // Color Palette System (unchanged but improved organization)
      class ColorPalette {
        constructor() {
          this.palettes = {
            ocean: {
              name: "Ocean Blue",
              background: "#ffffff",
              canvasBackground: "#ffffff",
              primary: "#0956ff",
              secondary: "#667eea",
              gridLight: "#e8f4fd",
              gridMedium: "#e3f2fd",
              gridDark: "#bbdefb",
              cellBorder: "#e9ecef",
              frameColor: "#667eea",
              centerGuide: "#764ba2",
              centerGuideStatic: "#f1f2f6",
              shadowColor: "#0956ff",
            },
            warm: {
              name: "Warm Grey",
              background: "#ffffff",
              canvasBackground: "#ffffff",
              primary: "#E8E6E3",
              secondary: "#a69384",
              gridLight: "#ebe8e4",
              gridMedium: "#e6e1db",
              gridDark: "#d4cfc7",
              cellBorder: "#ddd8d2",
              frameColor: "#a69384",
              centerGuide: "#8b7b6b",
              centerGuideStatic: "#e6e1db",
              shadowColor: "#8b7b6b",
            },
            dark: {
              name: "Dark Mode",
              background: "#201E1C",
              canvasBackground: "#201E1C",
              primary: "#000000",
              secondary: "#2d2d2d",
              gridLight: "#555555",
              gridMedium: "#4a4a4a",
              gridDark: "#363636",
              cellBorder: "#505050",
              frameColor: "#2d2d2d",
              centerGuide: "#1a1a1a",
              centerGuideStatic: "#4a4a4a",
              shadowColor: "#1a1a1a",
            },
            navy: {
              name: "Deep Blue",
              background: "#48505E",
              canvasBackground: "#48505E",
              primary: "#656E7C",
              secondary: "#3d566e",
              gridLight: "#4a6278",
              gridMedium: "#3f5a6f",
              gridDark: "#2f4352",
              cellBorder: "#445561",
              frameColor: "#3d566e",
              centerGuide: "#2c3e50",
              centerGuideStatic: "#4a6278",
              shadowColor: "#2c3e50",
            },
          };

          this.currentPalette = "ocean";
        }

        setPalette(paletteName) {
          if (this.palettes[paletteName]) {
            this.currentPalette = paletteName;
            this.updateCanvasBackground();
          }
        }

        getCurrentPalette() {
          return this.palettes[this.currentPalette];
        }

        getColor(colorKey) {
          return this.palettes[this.currentPalette][colorKey];
        }

        updateCanvasBackground() {
          const canvasContainer = document.querySelector(".canvas-container");
          if (canvasContainer) {
            canvasContainer.style.background = this.getColor("canvasBackground");
          }
        }
      }

      // Enhanced Configuration with static patterns
      class GridConfig {
        constructor() {
          this.params = {
            // Grid structure
            columns: 1,
            baseCells: 2,
            frameWidth: 900,
            frameHeight: 600,

            minConnectorThreshold: 0.0,
maxConnectorMultiplier: 8.0,
varianceSharpness: 1.0,
connectorOpacityLink: false,

flowSmoothness: 1.0,  // 0.5 = choppy, 1.0 = normal, 2.0 = very smooth

            // Movement system
            movementPattern: "standard",
            flowSpeed: 1.0,
            flowIntensity: 1.0,

            // Static pattern system
            staticPattern: "uniform",
            staticIntensity: 1.0,

            // Proportional system
            ratioSystem: "uniform",
            ratioVariance: 1.0,

            // Connector system
            connectorSize: 12,
            weightVariation: 2.5,
            connectorResponse: "proportional",

            // Display modes
            isFlowing: false,
            showGrid: true,
            colorPalette: "ocean",
          };
        }

        updateParam(key, value) {
          this.params[key] = value;
        }

        getParam(key) {
          return this.params[key];
        }
      }

      // Enhanced Movement System with grid structure integration
      class MovementSystems {
        constructor() {
          this.systems = {
            standard: this.calculateStatic.bind(this),
            offset: this.calculateOffset.bind(this),
            wave: this.calculateWave.bind(this),
            pulse: this.calculatePulse.bind(this),
            sweep: this.calculateSweep.bind(this),
            breath: this.calculateBreath.bind(this),
          };
        }

        calculate(pattern, columnIndex, cellIndex, totalColumns, time, intensity, smoothness = 1.0) {
  const system = this.systems[pattern];
  if (!system) return { heightMod: 1.0, connectorMod: 1.0, opacity: 1.0 };

  const normalizedColumn = totalColumns > 1 ? columnIndex / (totalColumns - 1) : 0.5;
  
  // Apply smoothness to time - higher values = smoother transitions
  const smoothTime = time / smoothness;
  
  const result = system(normalizedColumn, cellIndex, smoothTime, intensity);
  
  // Apply additional smoothing to the result if needed
  const smoothingFactor = Math.min(smoothness, 2.0); // Cap smoothing effect
  
  return {
    heightMod: Math.max(0.2, Math.min(2.5, result.heightMod)),
    connectorMod: Math.max(0.1, Math.min(3.0, result.connectorMod)),
    opacity: 1.0,
  };
}

        calculateStatic(normalizedColumn, cellIndex, time, intensity) {
          return { heightMod: 1.0, connectorMod: 1.0, opacity: 1.0 };
        }

        calculateOffset(normalizedColumn, cellIndex, time, intensity) {
          const columnOffset = Math.floor(normalizedColumn * 10) % 2 === 0 ? 1.0 : 0.8;
          const cellOffset = cellIndex % 2 === 0 ? 1.0 : 0.9;
          const combined = (columnOffset + cellOffset) / 2;
          
          return { 
            heightMod: combined, 
            connectorMod: 1.0 - (combined - 1.0) * 0.5, 
            opacity: 1.0 
          };
        }

        calculateWave(normalizedColumn, cellIndex, time, intensity) {
          const wavePhase = Math.sin(normalizedColumn * Math.PI * 2 + time * 2) * intensity;
          const cellWave = Math.sin(cellIndex * 0.5 + time * 1.5) * 0.3 * intensity;
          const combined = wavePhase + cellWave;
          
          return { 
            heightMod: 1.0 + combined * 0.5, 
            connectorMod: 1.0 + combined * 0.8, 
            opacity: 1.0 // Fixed: Solid color
          };
        }

        calculatePulse(normalizedColumn, cellIndex, time, intensity) {
          const pulsePhase = Math.sin(time * 3) * 0.5 + 0.5;
          const distance = Math.abs(normalizedColumn - 0.5) * 2;
          const cellPhase = Math.sin(cellIndex * 0.8 + time * 2) * 0.3;
          
          const modulation = pulsePhase * (1.0 - distance * 0.4) * intensity + cellPhase;
          
          return { 
            heightMod: 0.7 + modulation * 0.6, 
            connectorMod: 0.5 + modulation * 1.0, 
            opacity: 1.0 // Fixed: Solid color
          };
        }

        calculateSweep(normalizedColumn, cellIndex, time, intensity) {
          const sweepPos = (time * 0.5) % 2;
          const sweepPhase = sweepPos > 1 ? 2 - sweepPos : sweepPos;
          const sweepDistance = Math.abs(normalizedColumn - sweepPhase);
          const cellDelay = cellIndex * 0.1;
          
          const activation = Math.max(0, 1.0 - sweepDistance * 2) * intensity;
          const delayedActivation = Math.max(0, activation - cellDelay);
          
          return { 
            heightMod: 0.6 + delayedActivation * 0.8, 
            connectorMod: 0.4 + delayedActivation * 1.2, 
            opacity: 1.0 // Fixed: Solid color
          };
        }

        calculateBreath(normalizedColumn, cellIndex, time, intensity) {
          const breathPhase = Math.sin(time * 0.8) * 0.5 + 0.5;
          const centerDistance = Math.abs(normalizedColumn - 0.5);
          const cellBreath = Math.sin(cellIndex * 0.3 + time * 0.6) * 0.2;
          
          const expansion = breathPhase * (1.0 - centerDistance * 0.6) * intensity + cellBreath;
          
          return { 
            heightMod: 0.8 + expansion * 0.4, 
            connectorMod: 0.7 + expansion * 0.6, 
            opacity: 1.0 // Fixed: Solid color
          };
        }
      }

      // Static Pattern System for sophisticated layouts
      class StaticPatternSystem {
        constructor() {
          this.patterns = {
            uniform: this.calculateUniform.bind(this),
            alternating: this.calculateAlternating.bind(this),
            cascade: this.calculateCascade.bind(this),
            fibonacci: this.calculateFibonacci.bind(this),
            golden: this.calculateGolden.bind(this),
            mirror: this.calculateMirror.bind(this),
          };
        }

        calculate(pattern, columnIndex, cellIndex, totalColumns, totalCells, intensity) {
          const system = this.patterns[pattern];
          if (!system) return { heightMod: 1.0, connectorMod: 1.0, opacity: 1.0 };

          const result = system(columnIndex, cellIndex, totalColumns, totalCells, intensity);
          
          return {
            heightMod: Math.max(0.3, Math.min(2.5, result.heightMod)),
            connectorMod: Math.max(0.2, Math.min(3.0, result.connectorMod)),
            opacity: 1.0,
          };
        }

        calculateUniform(columnIndex, cellIndex, totalColumns, totalCells, intensity) {
          return { heightMod: 1.0, connectorMod: 1.0, opacity: 1.0 };
        }

        calculateAlternating(columnIndex, cellIndex, totalColumns, totalCells, intensity) {
          const columnAlt = columnIndex % 2 === 0 ? 1.0 : 0.7;
          const cellAlt = cellIndex % 2 === 0 ? 1.0 : 0.8;
          const checkerboard = (columnIndex + cellIndex) % 2 === 0 ? 1.0 : 0.75;
          
          const combined = (columnAlt + cellAlt + checkerboard) / 3;
          const modulated = 1.0 + (combined - 1.0) * intensity;
          
          return {
            heightMod: modulated,
            connectorMod: 1.0 + (combined - 1.0) * intensity * 0.8,
            opacity: 1.0
          };
        }

        calculateCascade(columnIndex, cellIndex, totalColumns, totalCells, intensity) {
          const columnPhase = columnIndex / Math.max(totalColumns - 1, 1);
          const cellPhase = cellIndex / Math.max(totalCells - 1, 1);
          
          // Create a cascading wave across columns and down cells
          const cascade = Math.sin(columnPhase * Math.PI * 2 + cellPhase * Math.PI) * 0.5 + 0.5;
          const modulated = 0.6 + cascade * 0.8 * intensity;
          
          return {
            heightMod: modulated,
            connectorMod: 0.5 + cascade * 1.0 * intensity,
            opacity: 1.0
          };
        }

        calculateFibonacci(columnIndex, cellIndex, totalColumns, totalCells, intensity) {
          const fibSequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
          
          // Use fibonacci numbers to create organic growth patterns
          const columnFib = fibSequence[columnIndex % fibSequence.length] / 34;
          const cellFib = fibSequence[cellIndex % fibSequence.length] / 34;
          
          // Combine for complex organic scaling
          const combined = (columnFib + cellFib * 0.7) / 1.7;
          const modulated = 0.5 + combined * intensity;
          
          return {
            heightMod: modulated,
            connectorMod: 0.4 + combined * 1.2 * intensity,
            opacity: 1.0
          };
        }

        calculateGolden(columnIndex, cellIndex, totalColumns, totalCells, intensity) {
          const goldenRatio = 1.618;
          
          // Use golden ratio for proportional scaling
          const columnRatio = Math.pow(goldenRatio, (columnIndex - totalColumns/2) * 0.3);
          const cellRatio = Math.pow(goldenRatio, (cellIndex - totalCells/2) * 0.2);
          
          // Normalize and apply intensity
          const normalized = (columnRatio * cellRatio) / (goldenRatio * goldenRatio);
          const modulated = 0.4 + normalized * 0.8 * intensity;
          
          return {
            heightMod: Math.max(0.3, Math.min(2.0, modulated)),
            connectorMod: Math.max(0.2, Math.min(2.5, normalized * intensity)),
            opacity: 1.0
          };
        }

        calculateMirror(columnIndex, cellIndex, totalColumns, totalCells, intensity) {
          // Create symmetrical patterns
          const columnCenter = (totalColumns - 1) / 2;
          const cellCenter = (totalCells - 1) / 2;
          
          const columnDistance = Math.abs(columnIndex - columnCenter) / columnCenter;
          const cellDistance = Math.abs(cellIndex - cellCenter) / cellCenter;
          
          // Combine distances for radial symmetry
          const combined = (columnDistance + cellDistance) / 2;
          const mirrored = 1.0 - combined * 0.5;
          const modulated = 0.5 + mirrored * 0.8 * intensity;
          
          return {
            heightMod: modulated,
            connectorMod: 0.6 + mirrored * 0.8 * intensity,
            opacity: 1.0
          };
        }
      }

      // FIXED MathSequences class - this was the missing piece!
      class MathSequences {
        constructor() {
          this.fibonacci = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
          this.golden = [1, 1.618, 2.618, 4.236, 6.854];
          this.harmonic = [1, 0.5, 0.333, 0.25, 0.2, 0.167, 0.143, 0.125];
        }

        getRatioSequence(cellCount, columnIndex, system, variance) {
          const ratios = [];

          for (let i = 0; i < cellCount; i++) {
            let ratio = 1.0;

            switch (system) {
              case "fibonacci":
                const fibIndex = i % this.fibonacci.length;
                ratio = this.fibonacci[fibIndex] / 8;
                break;
              case "golden":
                const goldenIndex = i % this.golden.length;
                ratio = this.golden[goldenIndex] / 6;
                break;
              case "harmonic":
                const harmonicIndex = i % this.harmonic.length;
                ratio = this.harmonic[harmonicIndex] * 4;
                break;
              case "uniform":
                ratio = 1.0;
                break;
            }

            const minRatio = 1 / variance;
            const maxRatio = variance;
            ratio = minRatio + ratio * (maxRatio - minRatio);
            ratios.push(Math.max(0.2, Math.min(4.0, ratio)));
          }

          return ratios;
        }
      }

      // Enhanced Connector System with better flow response
      // Enhanced Connector System with expanded variance range and better control
class ConnectorSystem {
  constructor(config) {
    this.config = config;
  }

  calculateConnectorHeight(baseSize, cellHeight, movement, time, columnIndex, cellIndex) {
    const variation = this.config.getParam("weightVariation");
    const response = this.config.getParam("connectorResponse");
    const minThreshold = this.config.getParam("minConnectorThreshold") || 0.0;
    const maxMultiplier = this.config.getParam("maxConnectorMultiplier") || 8.0;
    
    // DEBUG: Log what response mode we're in
    if (columnIndex === 0 && cellIndex === 0 && Math.floor(time * 5) % 25 === 0) {
      console.log('CONNECTOR RESPONSE MODE:', response);
    }
    
    let height = baseSize;
    let varianceMultiplier = 1.0;

    // Calculate base variance multiplier - keeping values more reasonable
    switch (response) {
      case "proportional":
        // Use cell height ratio with movement modifier
        const heightRatio = cellHeight / 60;
        varianceMultiplier = heightRatio * movement.connectorMod;
        break;
        
      case "inverse":
        // Inverse relationship - smaller cells get thicker connectors
        const inverseRatio = 60 / Math.max(cellHeight, 20);
        varianceMultiplier = inverseRatio * (2 - movement.connectorMod);
        break;
        
      case "fixed":
        // Fixed size regardless of cell height
        varianceMultiplier = 1.0;
        break;
        
      case "rhythmic":
        // DEBUG: Rhythmic variation that definitely stays visible
        const rhythm = Math.sin(time * 2 + columnIndex * 0.8 + cellIndex * 0.4) * 0.4 + 1.0; // Range 0.6 to 1.4
        varianceMultiplier = rhythm;
        
        // DEBUG: Log rhythmic values for first connector only - simplified condition
        if (columnIndex === 0 && cellIndex === 0) {
          console.log('RHYTHMIC VALUES:', {
            time: time.toFixed(2),
            rhythm: rhythm.toFixed(3),
            varianceMultiplier: varianceMultiplier.toFixed(3),
            baseSize,
            variation,
            minThreshold,
            maxMultiplier,
            willBeVisible: varianceMultiplier > 0.1
          });
        }
        break;
        
      case "organic":
        // Combine multiple factors for organic variation
        const organicBase = Math.sin(columnIndex * 0.7 + cellIndex * 0.4) * 0.3 + 0.7; // Range 0.4 to 1.0
        const organicFlow = Math.sin(time * 1.5 + columnIndex * 0.3) * 0.2 + 0.8; // Range 0.6 to 1.0
        varianceMultiplier = (organicBase * organicFlow) * movement.connectorMod;
        break;
        
      case "exponential":
        // FIXED: Less aggressive exponential scaling
        const expBase = Math.pow(Math.max(0.3, movement.connectorMod), 1.5); // Gentler curve
        const positionFactor = Math.sin((columnIndex + cellIndex) * 0.5) * 0.2 + 0.8; // Range 0.6 to 1.0
        varianceMultiplier = expBase * positionFactor;
        break;
        
      default:
        // DEBUG: Catch unknown response types
        console.log('UNKNOWN RESPONSE TYPE:', response);
        varianceMultiplier = 1.0;
        break;
    }

    // FIXED: Smoother variance application with less dramatic jumps
    // Clamp variance multiplier to reasonable range first
    varianceMultiplier = Math.max(0.1, Math.min(3.0, varianceMultiplier));
    
    // Apply variance more smoothly
    if (varianceMultiplier <= 1.0) {
      // Scale down smoothly to minimum
      const t = varianceMultiplier; // 0.1 to 1.0
      height = baseSize * (minThreshold + t * (variation - minThreshold));
    } else {
      // Scale up smoothly to maximum
      const t = (varianceMultiplier - 1.0) / 2.0; // 0 to 1 range for multipliers 1-3
      height = baseSize * (variation + t * (maxMultiplier - variation));
    }

    // Final bounds check
    const absoluteMin = Math.max(0, minThreshold);
    const absoluteMax = baseSize * maxMultiplier;
    
    const finalHeight = Math.max(absoluteMin, Math.min(absoluteMax, height));

    // DEBUG: Log final calculations for rhythmic mode - simplified condition
    if (response === "rhythmic" && columnIndex === 0 && cellIndex === 0) {
      console.log('RHYTHMIC FINAL HEIGHT:', {
        varianceMultiplier: varianceMultiplier.toFixed(3),
        calculatedHeight: height.toFixed(2),
        finalHeight: finalHeight.toFixed(2),
        absoluteMin,
        absoluteMax,
        isVisible: finalHeight > 1
      });
    }
    
    return finalHeight;
  }
}

// Enhanced Configuration with new parameters
function enhanceGridConfig(config) {
  // Add new parameters to the existing config
  const newParams = {
    minConnectorThreshold: 0.0,     // Minimum connector thickness (0 = invisible)
    maxConnectorMultiplier: 8.0,    // Maximum multiplier for connector thickness
    varianceSharpness: 1.0,         // Controls how sharp/smooth the variance transitions are
    connectorOpacityLink: false,    // Whether to link opacity to connector size
  };
  
  // Merge with existing params
  Object.assign(config.params, newParams);
  
  return config;
}

// Enhanced UI Controls for the new parameters
function addEnhancedConnectorControls() {
  // Find the Connection Joints section by looking for the specific text content
  const sections = document.querySelectorAll('.control-section');
  let connectionSection = null;
  
  sections.forEach(section => {
    const sectionTitle = section.querySelector('.section-title');
    if (sectionTitle && sectionTitle.textContent.includes('Connection Joints')) {
      connectionSection = section;
    }
  });
  
  if (connectionSection) {
    // Add new controls HTML
    const newControlsHTML = `
      <div class="control-item">
        <label class="control-label">Minimum Thickness (Zero allows invisible)</label>
        <div class="control-row">
          <input type="range" id="minConnectorThreshold" min="-2" max="1" step="0.1" value="0" />
          <span class="value-display" id="minConnectorThresholdValue">0</span>
        </div>
      </div>

      <div class="control-item">
        <label class="control-label">Maximum Multiplier</label>
        <div class="control-row">
          <input type="range" id="maxConnectorMultiplier" min="2" max="30" step="0.5" value="8" />
          <span class="value-display" id="maxConnectorMultiplierValue">8.0</span>
        </div>
      </div>

      <div class="control-item">
        <label class="control-label">Variance Sharpness</label>
        <div class="control-row">
          <input type="range" id="varianceSharpness" min="0.5" max="3.0" step="0.1" value="1.0" />
          <span class="value-display" id="varianceSharpnessValue">1.0</span>
        </div>
      </div>

      <div class="control-item">
        <label class="control-label">Advanced Response Types</label>
        <div class="button-grid">
          <button class="option-btn" data-connector="organic">
            Organic
          </button>
          <button class="option-btn" data-connector="exponential">
            Exponential
          </button>
        </div>
      </div>
    `;
    
    // Insert before the export button
    const exportBtn = connectionSection.querySelector('.export-btn');
    if (exportBtn) {
      exportBtn.insertAdjacentHTML('beforebegin', newControlsHTML);
    } else {
      // If no export button in this section, add at the end of controls-content
      const controlsContent = connectionSection.querySelector('.controls-content') || connectionSection;
      controlsContent.insertAdjacentHTML('beforeend', newControlsHTML);
    }
  }
}

// Enhanced setup function for the new controls
function setupEnhancedConnectorControls(gridSystem) {
  // Setup range controls for new parameters
  const newRangeControls = [
    "minConnectorThreshold", 
    "maxConnectorMultiplier", 
    "varianceSharpness"
  ];

  newRangeControls.forEach((controlId) => {
    const slider = document.getElementById(controlId);
    const display = document.getElementById(controlId + "Value");

    if (slider && display) {
      display.textContent = slider.value;

      slider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        gridSystem.config.updateParam(controlId, value);
        display.textContent = value % 1 === 0 ? value : value.toFixed(1);
      });
    }
  });

  // Setup new connector response types
  document.querySelectorAll('[data-connector]').forEach((btn) => {
    btn.addEventListener("click", () => {
      const value = btn.dataset.connector;
      gridSystem.config.updateParam("connectorResponse", value);
      gridSystem.updateButtonSelection('[data-connector]', value);
    });
  });
}

      // Main Grid System - Streamlined and Enhanced
      class StreamlinedGridSystem {
        constructor() {
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");

          // Initialize modular components
          this.config = new GridConfig();
          this.config = enhanceGridConfig(this.config);
          this.colorPalette = new ColorPalette();
          this.movementSystems = new MovementSystems();
          this.staticPatternSystem = new StaticPatternSystem();
          this.mathSequences = new MathSequences();
          this.connectorSystem = new ConnectorSystem(this.config);

          // Animation state
          this.time = 0;
          this.animationFrame = null;

          this.init();
        }

        init() {
          this.setupCanvas();
          this.setupControls();
          this.startAnimationLoop();
        }

        setupCanvas() {
          const container = this.canvas.parentElement;
          const resizeCanvas = () => {
            const rect = container.getBoundingClientRect();
            this.canvas.width = Math.floor(rect.width);
            this.canvas.height = Math.floor(rect.height);
          };

          resizeCanvas();
          window.addEventListener("resize", resizeCanvas);
        }

        setupControls() {
          const toggleBtn = document.getElementById("toggleBtn");
          const controls = document.getElementById("controls");
          
          if (toggleBtn && controls) {
            toggleBtn.addEventListener("click", () => {
              controls.classList.toggle("collapsed");
            });
          }

          this.setupRangeControls();
          this.setupButtonControls();
          this.setupViewControls();
          this.setupColorPalettes();
          this.setupMovementControls();
          
          addEnhancedConnectorControls();
setupEnhancedConnectorControls(this);
        }

        setupMovementControls() {
          const movementButtons = document.querySelectorAll("[data-movement]");
          const flowControls = document.getElementById("flowControls");
          const staticControls = document.getElementById("staticControls");

          movementButtons.forEach((btn) => {
            btn.addEventListener("click", () => {
              const movement = btn.dataset.movement;
              this.config.updateParam("movementPattern", movement);
              
              // Show/hide controls based on movement type
              if (movement === "standard") {
                flowControls.style.display = "none";
                staticControls.style.display = "block";
                this.config.updateParam("isFlowing", false);
                document.getElementById("stillMode").classList.add("active");
                document.getElementById("flowMode").classList.remove("active");
              } else {
                flowControls.style.display = "block";
                staticControls.style.display = "none";
                this.config.updateParam("isFlowing", true);
                document.getElementById("flowMode").classList.add("active");
                document.getElementById("stillMode").classList.remove("active");
              }

              this.updateButtonSelection("[data-movement]", movement);
              this.updateStatusIndicator();
            });
          });

          // Setup static pattern controls
          const staticButtons = document.querySelectorAll("[data-static]");
          staticButtons.forEach((btn) => {
            btn.addEventListener("click", () => {
              const pattern = btn.dataset.static;
              this.config.updateParam("staticPattern", pattern);
              this.updateButtonSelection("[data-static]", pattern);
            });
          });
        }

        setupColorPalettes() {
          const paletteOptions = document.querySelectorAll(".palette-option");

          paletteOptions.forEach((option) => {
            option.addEventListener("click", () => {
              const paletteName = option.dataset.palette;

              paletteOptions.forEach((opt) => opt.classList.remove("active"));
              option.classList.add("active");

              this.colorPalette.setPalette(paletteName);
              this.config.updateParam("colorPalette", paletteName);
            });
          });
        }

        setupRangeControls() {
            const rangeControls = [
  "columns", "baseCells", "frameWidth", "frameHeight",
  "ratioVariance", "connectorSize", "weightVariation",
  "flowSpeed", "flowIntensity", "staticIntensity", "flowSmoothness"  // Add this
];

          rangeControls.forEach((controlId) => {
            const slider = document.getElementById(controlId);
            const display = document.getElementById(controlId + "Value");

            if (slider && display) {
              display.textContent = slider.value;

              slider.addEventListener("input", (e) => {
                const value = parseFloat(e.target.value);
                this.config.updateParam(controlId, value);
                display.textContent = value % 1 === 0 ? value : value.toFixed(1);
              });
            }
          });
        }

        setupButtonControls() {
          ["ratio", "connector"].forEach((type) => {
            document.querySelectorAll(`[data-${type}]`).forEach((btn) => {
              btn.addEventListener("click", () => {
                const value = btn.dataset[type];

                if (type === "ratio") this.config.updateParam("ratioSystem", value);
                else if (type === "connector") this.config.updateParam("connectorResponse", value);

                this.updateButtonSelection(`[data-${type}]`, value);
              });
            });
          });
        }

        setupViewControls() {
          const stillBtn = document.getElementById("stillMode");
          const flowBtn = document.getElementById("flowMode");
          const gridBtn = document.getElementById("gridView");
          const cleanBtn = document.getElementById("cleanView");

          if (stillBtn && flowBtn) {
            stillBtn.addEventListener("click", () => {
              this.config.updateParam("isFlowing", false);
              this.config.updateParam("movementPattern", "standard");
              stillBtn.classList.add("active");
              flowBtn.classList.remove("active");
              document.getElementById("flowControls").style.display = "none";
              document.getElementById("staticControls").style.display = "block";
              this.updateButtonSelection("[data-movement]", "standard");
              this.updateStatusIndicator();
            });

            flowBtn.addEventListener("click", () => {
              // Only activate if not in standard movement
              const currentMovement = this.config.getParam("movementPattern");
              if (currentMovement === "standard") {
                this.config.updateParam("movementPattern", "wave");
                this.updateButtonSelection("[data-movement]", "wave");
                document.getElementById("flowControls").style.display = "block";
                document.getElementById("staticControls").style.display = "none";
              }
              this.config.updateParam("isFlowing", true);
              flowBtn.classList.add("active");
              stillBtn.classList.remove("active");
              this.updateStatusIndicator();
            });
          }

          if (gridBtn && cleanBtn) {
            gridBtn.addEventListener("click", () => {
              this.config.updateParam("showGrid", true);
              gridBtn.classList.add("active");
              cleanBtn.classList.remove("active");
              this.updateStatusIndicator();
            });

            cleanBtn.addEventListener("click", () => {
              this.config.updateParam("showGrid", false);
              cleanBtn.classList.add("active");
              gridBtn.classList.remove("active");
              this.updateStatusIndicator();
            });
          }
        }

        updateButtonSelection(selector, activeValue) {
          document.querySelectorAll(selector).forEach((btn) => {
            const dataAttr = selector.slice(6, -1);
            btn.classList.toggle("active", btn.dataset[dataAttr] === activeValue);
          });
        }

        updateStatusIndicator() {
          const indicator = document.getElementById("statusIndicator");
          if (!indicator) return;

          const isFlowing = this.config.getParam("isFlowing");
          const showGrid = this.config.getParam("showGrid");
          const movementPattern = this.config.getParam("movementPattern");

          let statusText = "";
          let className = "status-indicator";

          if (isFlowing && movementPattern !== "standard") {
            statusText = `Animated ${showGrid ? "Design" : "Export"} Mode`;
            className += " flowing";
          } else {
            statusText = `Static ${showGrid ? "Design" : "Export"} Mode`;
          }

          indicator.textContent = statusText;
          indicator.className = className;
        }

        generateColumnData(columnIndex, time) {
          const cells = [];
          const connectors = [];
          const baseCellCount = this.config.getParam("baseCells");
          const ratios = this.mathSequences.getRatioSequence(
            baseCellCount,
            columnIndex,
            this.config.getParam("ratioSystem"),
            this.config.getParam("ratioVariance")
          );

          const baseSpacing = 60;
          let currentY = 0;

          for (let cellIndex = 0; cellIndex < baseCellCount; cellIndex++) {
            let movement;

            // Calculate movement effects based on mode
            if (this.config.getParam("isFlowing")) {
  movement = this.movementSystems.calculate(
    this.config.getParam("movementPattern"),
    columnIndex,
    cellIndex,
    this.config.getParam("columns"),
    time,
    this.config.getParam("flowIntensity"),
    this.config.getParam("flowSmoothness")  // Add this line
  );
} else {
              // Use static pattern system for static mode
              movement = this.staticPatternSystem.calculate(
                this.config.getParam("staticPattern"),
                columnIndex,
                cellIndex,
                this.config.getParam("columns"),
                baseCellCount,
                this.config.getParam("staticIntensity")
              );
            }

            const currentRatio = ratios[cellIndex];
            const cellHeight = baseSpacing * currentRatio * movement.heightMod;

            cells.push({
              y: currentY,
              height: cellHeight,
              opacity: movement.opacity,
              index: cellIndex,
              columnIndex: columnIndex,
              movement: movement
            });

            currentY += cellHeight;

            // Add connector (except after last cell)
            if (cellIndex < baseCellCount - 1) {
              const connectorHeight = this.connectorSystem.calculateConnectorHeight(
                this.config.getParam("connectorSize"),
                cellHeight,
                movement,
                time,
                columnIndex,  // Add this
                cellIndex  
              );

              connectors.push({
                y: currentY,
                height: connectorHeight,
                opacity: movement.opacity,
                columnIndex: columnIndex
              });

              currentY += connectorHeight;
            }
          }

          return { cells, connectors, totalHeight: currentY };
        }

        startAnimationLoop() {
          const animate = (timestamp) => {
            if (this.config.getParam("isFlowing")) {
              this.time += 0.016 * this.config.getParam("flowSpeed");
            }

            this.render();
            this.updateStats();
            this.animationFrame = requestAnimationFrame(animate);
          };

          animate();
        }

        render() {
          // Clear canvas
          this.ctx.fillStyle = this.colorPalette.getColor("background");
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          const gridX = (this.canvas.width - this.config.getParam("frameWidth")) / 2;
          const gridY = (this.canvas.height - this.config.getParam("frameHeight")) / 2;
          const columnWidth = this.config.getParam("frameWidth") / this.config.getParam("columns");

          // Render grid guides if in design mode
          if (this.config.getParam("showGrid")) {
            this.renderGridGuides(gridX, gridY);
          }

          // Generate and render each column
          const columns = this.config.getParam("columns");
          let maxHeight = 0;

          for (let col = 0; col < columns; col++) {
            const columnData = this.generateColumnData(col, this.time);
            maxHeight = Math.max(maxHeight, columnData.totalHeight);
            
            const columnX = gridX + col * columnWidth;
            
            // Scale to fit frame height
            const scale = this.config.getParam("frameHeight") / columnData.totalHeight;
            
            this.renderColumn(columnData, columnX, gridY, columnWidth, scale);
          }
        }

        renderColumn(columnData, x, startY, width, scale) {
          const { cells, connectors } = columnData;

          // Render cells
          cells.forEach(cell => {
            const y = startY + cell.y * scale;
            const height = cell.height * scale;

            // Fixed: Always solid opacity
            this.ctx.globalAlpha = 1.0;
            
            // Cell background
            this.ctx.fillStyle = this.colorPalette.getColor("background");
            this.ctx.fillRect(x, y, width, height);

            // Cell border (if in design mode)
            if (this.config.getParam("showGrid")) {
              this.ctx.strokeStyle = this.colorPalette.getColor("cellBorder");
              this.ctx.lineWidth = 1;
              this.ctx.strokeRect(x, y, width, height);

              // Render subdivision guides
              this.renderCellSubdivisions(x, y, width, height, cell);
            }

            this.ctx.globalAlpha = 1.0;
          });

          // Render connectors
          connectors.forEach(connector => {
            const y = startY + connector.y * scale;
            const height = connector.height * scale;

            // Fixed: Always solid opacity
            this.ctx.globalAlpha = 1.0;
            this.ctx.fillStyle = this.colorPalette.getColor("primary");
            this.ctx.fillRect(x, y, width, height);
            this.ctx.globalAlpha = 1.0;
          });
        }

        renderCellSubdivisions(x, y, width, height, cell) {
          const subdivisions = Math.max(2, Math.ceil(height / 20));
          const unitHeight = height / subdivisions;

          this.ctx.save();
          this.ctx.strokeStyle = this.colorPalette.getColor("gridLight");
          this.ctx.lineWidth = 0.5;
          this.ctx.globalAlpha = 0.6;

          for (let i = 1; i < subdivisions; i++) {
            const lineY = y + i * unitHeight;
            this.ctx.beginPath();
            this.ctx.moveTo(x + width * 0.1, lineY);
            this.ctx.lineTo(x + width * 0.9, lineY);
            this.ctx.stroke();
          }

          this.ctx.restore();
        }

        renderGridGuides(gridX, gridY) {
          const frameWidth = this.config.getParam("frameWidth");
          const frameHeight = this.config.getParam("frameHeight");

          // Draw frame boundary
          this.ctx.strokeStyle = this.colorPalette.getColor("frameColor");
          this.ctx.lineWidth = 2;
          this.ctx.setLineDash([8, 8]);
          this.ctx.strokeRect(gridX, gridY, frameWidth, frameHeight);
          this.ctx.setLineDash([]);

          // Column guides
          if (this.config.getParam("columns") > 1) {
            this.ctx.strokeStyle = this.colorPalette.getColor("cellBorder");
            this.ctx.lineWidth = 1;
            const columnWidth = frameWidth / this.config.getParam("columns");

            for (let col = 1; col < this.config.getParam("columns"); col++) {
              const x = gridX + col * columnWidth;
              this.ctx.beginPath();
              this.ctx.moveTo(x, gridY);
              this.ctx.lineTo(x, gridY + frameHeight);
              this.ctx.stroke();
            }
          }

          // Center guides
          this.ctx.strokeStyle = this.colorPalette.getColor("centerGuideStatic");
          this.ctx.lineWidth = 0.5;
          this.ctx.setLineDash([6, 6]);

          // Horizontal center
          this.ctx.beginPath();
          this.ctx.moveTo(gridX, gridY + frameHeight / 2);
          this.ctx.lineTo(gridX + frameWidth, gridY + frameHeight / 2);
          this.ctx.stroke();

          // Vertical center
          this.ctx.beginPath();
          this.ctx.moveTo(gridX + frameWidth / 2, gridY);
          this.ctx.lineTo(gridX + frameWidth / 2, gridY + frameHeight);
          this.ctx.stroke();

          this.ctx.setLineDash([]);
        }

        updateStats() {
          const statsElement = document.getElementById("stats");
          if (!statsElement) return;

          const columns = this.config.getParam("columns");
          const baseCells = this.config.getParam("baseCells");
          const frameWidth = this.config.getParam("frameWidth");
          const frameHeight = this.config.getParam("frameHeight");
          const ratioSystem = this.config.getParam("ratioSystem");
          const paletteName = this.colorPalette.getCurrentPalette().name;
          const movementPattern = this.config.getParam("movementPattern");

          const flowState = this.config.getParam("isFlowing") && movementPattern !== "standard" ? "Animated" : "Static";
          const viewMode = this.config.getParam("showGrid") ? "Design" : "Export";

          const statsText = `${flowState} ${viewMode}: ${columns}×${baseCells} | ${frameWidth}×${frameHeight} | ${ratioSystem} | ${paletteName}`;
          statsElement.textContent = statsText;
        }
      }

      // Global functions
      window.exportGrid = function () {
        const canvas = document.getElementById("canvas");
        if (!canvas) return;

        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
        const mode = window.gridSystem.config.getParam("showGrid") ? "design" : "export";
        const flowState = window.gridSystem.config.getParam("isFlowing") ? "animated" : "static";
        const palette = window.gridSystem.colorPalette.currentPalette;

        const link = document.createElement("a");
        link.download = `grid-v3-${mode}-${flowState}-${palette}-${timestamp}.png`;
        link.href = canvas.toDataURL();
        link.click();
      };

      // Initialize system
      document.addEventListener("DOMContentLoaded", () => {
        const canvas = document.getElementById("canvas");
        if (!canvas) {
          console.error("Canvas element not found!");
          return;
        }

        const gridSystem = new StreamlinedGridSystem();
        window.gridSystem = gridSystem;

        // Enhanced keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          switch (e.key.toLowerCase()) {
            case " ":
              e.preventDefault();
              const stillBtn = document.getElementById("stillMode");
              const flowBtn = document.getElementById("flowMode");
              if (stillBtn && flowBtn) {
                if (gridSystem.config.getParam("isFlowing")) {
                  stillBtn.click();
                } else {
                  flowBtn.click();
                }
              }
              break;

            case "v":
              e.preventDefault();
              const gridBtn = document.getElementById("gridView");
              const cleanBtn = document.getElementById("cleanView");
              if (gridBtn && cleanBtn) {
                if (gridSystem.config.getParam("showGrid")) {
                  cleanBtn.click();
                } else {
                  gridBtn.click();
                }
              }
              break;

            case "c":
              e.preventDefault();
              const toggleBtn = document.getElementById("toggleBtn");
              if (toggleBtn) toggleBtn.click();
              break;

            case "e":
              e.preventDefault();
              if (window.exportGrid) exportGrid();
              break;

            case "r":
              e.preventDefault();
              location.reload();
              break;

            // Movement shortcuts
            case "1": e.preventDefault(); document.querySelector('[data-movement="standard"]')?.click(); break;
            case "2": e.preventDefault(); document.querySelector('[data-movement="wave"]')?.click(); break;
            case "3": e.preventDefault(); document.querySelector('[data-movement="pulse"]')?.click(); break;
            case "4": e.preventDefault(); document.querySelector('[data-movement="sweep"]')?.click(); break;
            case "5": e.preventDefault(); document.querySelector('[data-movement="breath"]')?.click(); break;
            case "6": e.preventDefault(); document.querySelector('[data-movement="offset"]')?.click(); break;
          }
        });

        console.log("🌊 Streamlined Grid System v3.0 initialized");
        console.log("✨ Key improvements:");
        console.log("  • Logical control grouping");
        console.log("  • Movement affects entire grid structure");
        console.log("  • Enhanced connector flow response");
        console.log("  • Streamlined terminology");
        console.log("⌨️  Controls: Space=flow, V=view, C=controls, E=export");
        console.log("🎮 Movement: 1=Static, 2=Wave, 3=Pulse, 4=Sweep, 5=Breath, 6=Offset");
      });
    </script>
  </body>
</html>
