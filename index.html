<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grid Architecture - Morphological Design System</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display",
          "Helvetica Neue", sans-serif;
        background: #fafbfc;
        height: 100vh;
        display: flex;
        overflow: hidden;
        color: #1a1a1a;
      }

      .controls {
        width: 320px;
        background: #ffffff;
        border-right: 1px solid #e8eaed;
        overflow-y: auto;
        z-index: 10;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.04);
        position: relative;
      }

      .controls.collapsed {
        transform: translateX(-100%);
      }

      .header {
        padding: 24px 24px 20px 24px;
        border-bottom: 1px solid #f1f3f4;
        background: #ffffff;
      }

      .logo-area {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .logo-placeholder {
  width: 32px;
  height: 32px;
  border-radius: 8px;
  overflow: hidden;
}

.logo-placeholder img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

      .title-group {
        flex: 1;
      }

      .app-title {
        font-size: 18px;
        font-weight: 600;
        color: #1a1a1a;
        line-height: 1.2;
        margin-bottom: 2px;
      }

      .app-subtitle {
        font-size: 12px;
        color: #5f6368;
        font-weight: 400;
        line-height: 1.3;
      }

      .toggle-btn {
        position: absolute;
        right: -48px;
        top: 24px;
        width: 40px;
        height: 40px;
        background: #ffffff;
        border: 1px solid #e8eaed;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .toggle-btn:hover {
        background: #f8f9fa;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      }

      .controls-content {
        padding: 0 24px 24px 24px;
      }

      .control-section {
        margin-bottom: 32px;
      }

      .control-section:last-child {
        margin-bottom: 0;
      }

      .section-title {
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 16px;
        color: #3c4043;
        letter-spacing: -0.01em;
      }

      .control-item {
        margin-bottom: 20px;
      }

      .control-item:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: block;
        font-size: 12px;
        color: #5f6368;
        margin-bottom: 8px;
        font-weight: 500;
        letter-spacing: -0.01em;
      }

      .control-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      input[type="range"] {
        flex: 1;
        height: 2px;
        background: #e8eaed;
        border-radius: 1px;
        outline: none;
        -webkit-appearance: none;
        cursor: pointer;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        background: #0956ff;
        border-radius: 50%;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(25, 118, 210, 0.3);
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        background: #0956ff;
        transform: scale(1.1);
        box-shadow: 0 3px 8px rgba(25, 118, 210, 0.4);
      }

      input[type="range"]:focus::-webkit-slider-thumb {
        background: #0956ff;
        transform: scale(1.1);
        box-shadow: 0 0 0 4px rgba(25, 118, 210, 0.12);
      }

      .value-display {
        font-size: 12px;
        color: #5f6368;
        width: 32px;
        text-align: right;
        font-weight: 500;
        font-variant-numeric: tabular-nums;
      }

      .button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 8px;
      }

      .option-btn {
        padding: 10px 12px;
        border: 1px solid #e8eaed;
        border-radius: 6px;
        background: #ffffff;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
        font-weight: 500;
        color: #3c4043;
        letter-spacing: -0.01em;
      }

      .option-btn:hover {
        background: #f8f9fa;
        border-color: #dadce0;
      }

      .option-btn.active {
        background: #0956ff;
        color: #ffffff;
        border-color: #0956ff;
        box-shadow: 0 2px 4px rgba(25, 118, 210, 0.2);
      }

      .primary-controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 20px;
      }

      .primary-btn {
        padding: 12px 16px;
        border: 1px solid #e8eaed;
        border-radius: 8px;
        background: #ffffff;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        text-align: center;
        font-weight: 500;
        color: #3c4043;
        letter-spacing: -0.01em;
      }

      .primary-btn:hover {
        background: #f8f9fa;
        border-color: #dadce0;
      }

      .primary-btn.active {
        background: #0956ff;
        color: #ffffff;
        border-color: #0956ff;
        box-shadow: 0 2px 6px rgba(25, 118, 210, 0.24);
      }

      .canvas-container {
        flex: 1;
        background: #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      #canvas {
        background: #ffffff;
        display: block;
        border-radius: 0;
        box-shadow: none;
      }

      .export-btn {
        width: 100%;
        padding: 12px 16px;
        background: #0956ff;
        color: #ffffff;
        border: none;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        letter-spacing: -0.01em;
        margin-top: 24px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .export-btn:hover {
        background: #0956ff;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
      }

      .export-btn:active {
        transform: translateY(0);
      }

      .stats {
        background: #f8f9fa;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 11px;
        color: #5f6368;
        margin-top: 20px;
        border: 1px solid #f1f3f4;
        line-height: 1.4;
        font-weight: 400;
        font-variant-numeric: tabular-nums;
      }

      .status-indicator {
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 6px;
        padding: 8px 12px;
        margin: 12px 0;
        font-size: 11px;
        color: #0956ff;
        text-align: center;
        font-weight: 500;
        letter-spacing: -0.01em;
      }

      .status-indicator.flowing {
        background: #e8f5e8;
        border-color: #c8e6c9;
        color: #2e7d32;
      }

      /* Grid-inspired dividers */
      .section-divider {
        height: 1px;
        background: linear-gradient(
          90deg,
          transparent 0%,
          #e8eaed 20%,
          #e8eaed 80%,
          transparent 100%
        );
        margin: 24px 0;
      }

      /* Subtle grid pattern in background */
      .controls::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: linear-gradient(#f8f9fa 1px, transparent 1px),
          linear-gradient(90deg, #f8f9fa 1px, transparent 1px);
        background-size: 20px 20px;
        opacity: 0.3;
        pointer-events: none;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <div class="controls" id="controls">
      <div class="toggle-btn" id="toggleBtn" title="Toggle Controls">
        <svg
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="#5f6368"
          stroke-width="2"
        >
          <polyline points="15,18 9,12 15,6"></polyline>
        </svg>
      </div>

      <div class="header">
        <div class="logo-area">
            <div class="logo-placeholder">
                <img src="./images/gmLogo.png" alt="Logo" />
              </div>
          <div class="title-group">
            <div class="app-title">Underline Pattern</div>
            <div class="app-subtitle">Generative design system</div>
          </div>
        </div>
      </div>

      <div class="controls-content">
        <div class="control-section">
          <div class="primary-controls">
            <button class="primary-btn active" id="gridView">Grid View</button>
            <button class="primary-btn" id="cleanView">Clean View</button>
          </div>

          <div class="primary-controls">
            <button class="primary-btn active" id="stillMode">Static</button>
            <button class="primary-btn" id="flowMode">Flow</button>
          </div>

          <div class="status-indicator" id="statusIndicator">
           
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">Animation</div>

          <div class="control-item">
            <label class="control-label">Flow Speed</label>
            <div class="control-row">
              <input
                type="range"
                id="flowSpeed"
                min="0.3"
                max="2.5"
                step="0.1"
                value="1"
              />
              <span class="value-display" id="flowSpeedValue">1.0</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Smoothness</label>
            <div class="control-row">
              <input
                type="range"
                id="morphSmoothness"
                min="2"
                max="12"
                step="0.5"
                value="6"
              />
              <span class="value-display" id="morphSmoothnessValue">6.0</span>
            </div>
          </div>
        </div>

        <div class="section-divider"></div>

        <div class="control-section">
          <div class="section-title">Grid Structure</div>

          <div class="control-item">
            <label class="control-label">Columns</label>
            <div class="control-row">
              <input type="range" id="columns" min="4" max="12" value="6" />
              <span class="value-display" id="columnsValue">6</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Base Cells</label>
            <div class="control-row">
              <input type="range" id="baseCells" min="6" max="18" value="10" />
              <span class="value-display" id="baseCellsValue">10</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Width</label>
            <div class="control-row">
              <input
                type="range"
                id="frameWidth"
                min="600"
                max="1200"
                value="800"
              />
              <span class="value-display" id="frameWidthValue">800</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Height</label>
            <div class="control-row">
              <input
                type="range"
                id="frameHeight"
                min="400"
                max="800"
                value="600"
              />
              <span class="value-display" id="frameHeightValue">600</span>
            </div>
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">Density Flow</div>

          <div class="control-item">
            <label class="control-label">Pattern</label>
            <div class="button-grid">
              <button class="option-btn active" data-density="wave">
                Wave
              </button>
              <button class="option-btn" data-density="pulse">Pulse</button>
              <button class="option-btn" data-density="sweep">Sweep</button>
              <button class="option-btn" data-density="breath">Breath</button>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Range</label>
            <div class="control-row">
              <input
                type="range"
                id="densityRange"
                min="0.4"
                max="2.2"
                step="0.1"
                value="1.2"
              />
              <span class="value-display" id="densityRangeValue">1.2</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Intensity</label>
            <div class="control-row">
              <input
                type="range"
                id="flowIntensity"
                min="0.3"
                max="1.8"
                step="0.1"
                value="0.8"
              />
              <span class="value-display" id="flowIntensityValue">0.8</span>
            </div>
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">Mathematical Ratios</div>

          <div class="control-item">
            <label class="control-label">System</label>
            <div class="button-grid">
              <button class="option-btn active" data-ratio="fibonacci">
                Fibonacci
              </button>
              <button class="option-btn" data-ratio="golden">Golden</button>
              <button class="option-btn" data-ratio="harmonic">Harmonic</button>
              <button class="option-btn" data-ratio="prime">Prime</button>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Variance</label>
            <div class="control-row">
              <input
                type="range"
                id="ratioVariance"
                min="1.2"
                max="4.5"
                step="0.1"
                value="2.8"
              />
              <span class="value-display" id="ratioVarianceValue">2.8</span>
            </div>
          </div>
        </div>

        <div class="control-section">
          <div class="section-title">Connector Logic</div>

          <div class="control-item">
            <label class="control-label">Size</label>
            <div class="control-row">
              <input
                type="range"
                id="connectorSize"
                min="2"
                max="14"
                value="5"
              />
              <span class="value-display" id="connectorSizeValue">5</span>
            </div>
          </div>

          <div class="control-item">
            <label class="control-label">Response</label>
            <div class="button-grid">
              <button class="option-btn active" data-connector="fixed">
                Fixed
              </button>
              <button class="option-btn" data-connector="flow">Flow</button>
              <button class="option-btn" data-connector="inverse">
                Inverse
              </button>
              <button class="option-btn" data-connector="pulse">Pulse</button>
            </div>
          </div>
        </div>

        <button class="export-btn" onclick="exportGrid()">
          Export Current State
        </button>

        <div class="stats" id="stats">
          Static Grid: 6×10 | 800×600 | Fibonacci+Wave
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="canvas"></canvas>
    </div>

    <!-- You can add your existing JavaScript here -->
    <script>
      class MorphologicalConstrainedGrid {
        constructor() {
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");

          // Enhanced parameters for morphological animation
          this.params = {
            // Grid architecture
            columns: 6,
            baseCells: 10,
            frameWidth: 800,
            frameHeight: 600,

            // Mathematical systems
            ratioSystem: "fibonacci",
            ratioVariance: 2.8,

            // Density flow
            densityPattern: "wave",
            densityRange: 1.2,
            flowIntensity: 0.8,

            // Connector flow
            connectorSize: 5,
            connectorResponse: "fixed",

            // Morphological animation
            isFlowing: false,
            flowSpeed: 1,
            morphSmoothness: 6,
            showGrid: true,
          };

          // Morphological state system - tracks continuous transformations
          this.morphState = {
            // Cell morphology - tracks each cell's continuous state
            cells: new Map(), // cellId -> { height, ratio, targetHeight, targetRatio, velocity }

            // Column morphology - tracks density changes
            columns: new Map(), // columnIndex -> { cellCount, targetCellCount, velocity }

            // Connector morphology - tracks connector changes
            connectors: new Map(), // connectorId -> { height, targetHeight, velocity }

            // Flow timing
            lastUpdate: 0,
            updateInterval: 80, // milliseconds between morphological updates

            // Continuous interpolation
            interpolationSpeed: 0.02,

            // Morphological forces
            expansionForce: 0.15,
            contractionForce: 0.12,
            dampening: 0.85,
          };

          // Mathematical sequences
          this.fibonacci = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
          this.golden = [1, 1.618, 2.618, 4.236, 6.854]; // Golden ratio powers
          this.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];

          this.time = 0;
          this.animationFrame = null;
          this.renderedCells = [];
          this.renderedConnectors = [];

          // Movement system registry for future extensibility
          this.movementSystems = {
            wave: this.calculateWaveInterference.bind(this),
            pulse: this.calculatePulseMovement.bind(this),
            sweep: this.calculateSweepMovement.bind(this),
            breath: this.calculateBreathMovement.bind(this),
            // Future systems can be added here:
            // harmonic: this.calculateHarmonicResonance.bind(this),
            // cellular: this.calculateCellularAutomata.bind(this),
            // gravity: this.calculateGravitationalField.bind(this),
          };

          this.init();
        }

        init() {
          this.setupCanvas();
          this.setupControls();
          this.initializeMorphology();
          this.generateInitialState();
          this.startMorphologicalLoop();
        }

        setupCanvas() {
          const container = this.canvas.parentElement;
          const resizeCanvas = () => {
            const rect = container.getBoundingClientRect();
            this.canvas.width = Math.floor(rect.width);
            this.canvas.height = Math.floor(rect.height);
            this.generateInitialState();
          };

          resizeCanvas();
          window.addEventListener("resize", resizeCanvas);
        }

        setupControls() {
          // Collapsible controls - add null checks
          const toggleBtn = document.getElementById("toggleBtn");
          const controls = document.getElementById("controls");

          if (toggleBtn && controls) {
            toggleBtn.addEventListener("click", () => {
              controls.classList.toggle("collapsed");
            });
          }

          // Range controls with morphological updates
          const rangeControls = [
            "columns",
            "baseCells",
            "frameWidth",
            "frameHeight",
            "ratioVariance",
            "densityRange",
            "flowIntensity",
            "connectorSize",
            "flowSpeed",
            "morphSmoothness",
          ];

          rangeControls.forEach((controlId) => {
            const slider = document.getElementById(controlId);
            const display = document.getElementById(controlId + "Value");

            if (slider && display) {
              display.textContent = slider.value;

              slider.addEventListener("input", (e) => {
                const value = parseFloat(e.target.value);
                this.params[controlId] = value;
                display.textContent =
                  value % 1 === 0 ? value : value.toFixed(1);

                // Trigger morphological update
                this.scheduleMorphologicalUpdate();
              });
            }
          });

          this.setupPatternControls();
          this.setupAnimationControls();
          this.setupViewControls();
        }

        setupPatternControls() {
          ["ratio", "density", "connector"].forEach((type) => {
            document.querySelectorAll(`[data-${type}]`).forEach((btn) => {
              btn.addEventListener("click", () => {
                const value = btn.dataset[type];

                if (type === "ratio") this.params.ratioSystem = value;
                else if (type === "density") this.params.densityPattern = value;
                else if (type === "connector")
                  this.params.connectorResponse = value;

                this.updateButtonSelection(`[data-${type}]`, value);
                this.scheduleMorphologicalUpdate();
              });
            });
          });
        }

        setupAnimationControls() {
          const stillBtn = document.getElementById("stillMode");
          const flowBtn = document.getElementById("flowMode");

          if (stillBtn && flowBtn) {
            stillBtn.addEventListener("click", () => {
              this.params.isFlowing = false;
              stillBtn.classList.add("active");
              flowBtn.classList.remove("active");
            });

            flowBtn.addEventListener("click", () => {
              this.params.isFlowing = true;
              flowBtn.classList.add("active");
              stillBtn.classList.remove("active");
            });
          }
        }

        setupViewControls() {
          const gridBtn = document.getElementById("gridView");
          const cleanBtn = document.getElementById("cleanView");

          if (gridBtn && cleanBtn) {
            gridBtn.addEventListener("click", () => {
              this.params.showGrid = true;
              gridBtn.classList.add("active");
              cleanBtn.classList.remove("active");
            });

            cleanBtn.addEventListener("click", () => {
              this.params.showGrid = false;
              cleanBtn.classList.add("active");
              gridBtn.classList.remove("active");
            });
          }
        }

        updateButtonSelection(selector, activeValue) {
          document.querySelectorAll(selector).forEach((btn) => {
            const dataAttr = selector.slice(6, -1);
            btn.classList.toggle(
              "active",
              btn.dataset[dataAttr] === activeValue
            );
          });
        }

        // MORPHOLOGICAL SYSTEM
        initializeMorphology() {
          this.morphState.cells.clear();
          this.morphState.columns.clear();
          this.morphState.connectors.clear();
          this.morphState.lastUpdate = Date.now();
        }

        scheduleMorphologicalUpdate() {
          // Force immediate morphological recalculation
          this.morphState.lastUpdate =
            Date.now() - this.morphState.updateInterval;
        }

        updateMorphologicalTargets() {
          const currentTime = Date.now();
          const timeSinceUpdate = currentTime - this.morphState.lastUpdate;

          if (timeSinceUpdate >= this.morphState.updateInterval) {
            // Generate new morphological targets
            this.calculateMorphologicalTargets();
            this.morphState.lastUpdate = currentTime;
          }

          // Apply continuous morphological forces
          this.applyMorphologicalForces();
        }

        calculateMorphologicalTargets() {
          // Calculate target states for each column
          for (let col = 0; col < this.params.columns; col++) {
            const targetDensity = this.calculateDensityFlow(col);
            const targetCellCount = Math.round(
              this.params.baseCells * targetDensity
            );

            // Get or create column state
            if (!this.morphState.columns.has(col)) {
              this.morphState.columns.set(col, {
                cellCount: targetCellCount,
                targetCellCount: targetCellCount,
                velocity: 0,
              });
            } else {
              const columnState = this.morphState.columns.get(col);
              columnState.targetCellCount = targetCellCount;
            }

            // Calculate target cell properties
            this.calculateCellTargets(col, targetCellCount);
          }
        }

        calculateCellTargets(columnIndex, cellCount) {
          const ratios = this.calculateRatioSequence(cellCount, columnIndex);
          const availableHeight = this.params.frameHeight * 0.85;
          const connectorSpace = this.params.connectorSize * (cellCount - 1);
          const cellSpace = availableHeight - connectorSpace;
          const totalRatio = ratios.reduce((sum, ratio) => sum + ratio, 0);

          for (let i = 0; i < cellCount; i++) {
            const cellId = `${columnIndex}-${i}`;
            const targetHeight = (cellSpace * ratios[i]) / totalRatio;
            const targetRatio = ratios[i];

            if (!this.morphState.cells.has(cellId)) {
              this.morphState.cells.set(cellId, {
                height: targetHeight,
                ratio: targetRatio,
                targetHeight: targetHeight,
                targetRatio: targetRatio,
                velocityHeight: 0,
                velocityRatio: 0,
              });
            } else {
              const cellState = this.morphState.cells.get(cellId);
              cellState.targetHeight = targetHeight;
              cellState.targetRatio = targetRatio;
            }

            // Calculate connector targets
            if (i < cellCount - 1) {
              const connectorId = `${columnIndex}-${i}-connector`;
              const targetConnectorHeight = this.calculateConnectorTarget(
                cellId,
                targetHeight
              );

              if (!this.morphState.connectors.has(connectorId)) {
                this.morphState.connectors.set(connectorId, {
                  height: targetConnectorHeight,
                  targetHeight: targetConnectorHeight,
                  velocity: 0,
                });
              } else {
                const connectorState =
                  this.morphState.connectors.get(connectorId);
                connectorState.targetHeight = targetConnectorHeight;
              }
            }
          }
        }

        applyMorphologicalForces() {
          const dampening = this.morphState.dampening;
          const speed =
            this.morphState.interpolationSpeed * this.params.morphSmoothness;

          // Apply forces to columns (cell count changes)
          this.morphState.columns.forEach((columnState, columnIndex) => {
            const diff = columnState.targetCellCount - columnState.cellCount;

            if (Math.abs(diff) > 0.1) {
              // Apply expansion/contraction force
              const force =
                diff > 0
                  ? this.morphState.expansionForce
                  : this.morphState.contractionForce;
              columnState.velocity += diff * force;
              columnState.velocity *= dampening;
              columnState.cellCount += columnState.velocity * speed;

              // Clamp to reasonable bounds
              columnState.cellCount = Math.max(
                1,
                Math.min(20, columnState.cellCount)
              );
            }
          });

          // Apply forces to cells (height and ratio changes)
          this.morphState.cells.forEach((cellState, cellId) => {
            // Height morphology
            const heightDiff = cellState.targetHeight - cellState.height;
            if (Math.abs(heightDiff) > 0.5) {
              const heightForce =
                heightDiff > 0
                  ? this.morphState.expansionForce
                  : this.morphState.contractionForce;
              cellState.velocityHeight += heightDiff * heightForce;
              cellState.velocityHeight *= dampening;
              cellState.height += cellState.velocityHeight * speed;
              cellState.height = Math.max(2, cellState.height);
            }

            // Ratio morphology
            const ratioDiff = cellState.targetRatio - cellState.ratio;
            if (Math.abs(ratioDiff) > 0.01) {
              cellState.velocityRatio += ratioDiff * 0.1;
              cellState.velocityRatio *= dampening;
              cellState.ratio += cellState.velocityRatio * speed;
              cellState.ratio = Math.max(0.2, Math.min(5, cellState.ratio));
            }
          });

          // Apply forces to connectors
          this.morphState.connectors.forEach((connectorState, connectorId) => {
            const diff = connectorState.targetHeight - connectorState.height;
            if (Math.abs(diff) > 0.2) {
              const force =
                diff > 0
                  ? this.morphState.expansionForce
                  : this.morphState.contractionForce;
              connectorState.velocity += diff * force;
              connectorState.velocity *= dampening;
              connectorState.height += connectorState.velocity * speed;
              connectorState.height = Math.max(
                1,
                Math.min(20, connectorState.height)
              );
            }
          });
        }

        // CALCULATION SYSTEMS
        calculateDensityFlow(columnIndex) {
          const normalizedPos =
            columnIndex / Math.max(1, this.params.columns - 1);
          const timeOffset = this.params.isFlowing
            ? this.time * this.params.flowSpeed
            : 0;

          // Use modular movement system
          const movementSystem =
            this.movementSystems[this.params.densityPattern];
          let density = movementSystem
            ? movementSystem(normalizedPos, timeOffset)
            : 1.0;

          return Math.max(
            0.3,
            Math.min(
              2.0,
              density * this.params.densityRange * this.params.flowIntensity
            )
          );
        }

        // WAVE INTERFERENCE SYSTEM
        calculateWaveInterference(normalizedPos, timeOffset) {
          // Golden ratio wave source at φ position
          const goldenRatioPos = 0.618;
          const goldenWave = this.createWaveFromSource(
            normalizedPos,
            goldenRatioPos,
            timeOffset,
            1.0, // amplitude
            2.4, // frequency
            0 // phase offset
          );

          // Fibonacci sequence wave source at 1/φ position
          const fibonacciPos = 1 - 0.618; // 0.382
          const fibonacciWave = this.createWaveFromSource(
            normalizedPos,
            fibonacciPos,
            timeOffset,
            0.7, // amplitude
            1.618, // frequency (golden ratio)
            Math.PI / 3 // phase offset
          );

          // Prime ratio wave source at 1/3 position
          const primePos = 1 / 3;
          const primeWave = this.createWaveFromSource(
            normalizedPos,
            primePos,
            timeOffset,
            0.5, // amplitude
            3.0, // frequency
            Math.PI / 2 // phase offset
          );

          // Constructive/destructive interference
          const interference = goldenWave + fibonacciWave + primeWave;

          // Normalize and apply base density
          const normalizedInterference = Math.tanh(interference) * 0.5 + 0.5;

          return 0.4 + normalizedInterference * 1.2;
        }

        createWaveFromSource(
          position,
          sourcePos,
          time,
          amplitude,
          frequency,
          phaseOffset
        ) {
          // Distance-based amplitude decay
          const distance = Math.abs(position - sourcePos);
          const distanceDecay = Math.exp(-distance * 2.0); // exponential decay

          // Wave equation with distance and time
          const spatialPhase = distance * frequency * Math.PI;
          const temporalPhase = time * frequency;
          const totalPhase = spatialPhase + temporalPhase + phaseOffset;

          // Wave with distance-based amplitude modulation
          return amplitude * distanceDecay * Math.sin(totalPhase);
        }

        // LEGACY MOVEMENT SYSTEMS (refactored for modularity)
        calculatePulseMovement(normalizedPos, timeOffset) {
          const pulsePhase = Math.sin(timeOffset * 2) * 0.5 + 0.5;
          const distance = Math.abs(normalizedPos - 0.5) * 2;
          return 0.4 + pulsePhase * (1.2 - distance);
        }

        calculateSweepMovement(normalizedPos, timeOffset) {
          const sweepPos = (timeOffset * 0.3) % 2;
          const sweepDistance = Math.abs(
            normalizedPos - (sweepPos > 1 ? 2 - sweepPos : sweepPos)
          );
          return 0.6 + (1 - sweepDistance) * 0.8;
        }

        calculateBreathMovement(normalizedPos, timeOffset) {
          const breathPhase = Math.sin(timeOffset * 0.8) * 0.5 + 0.5;
          const centerDistance = Math.abs(normalizedPos - 0.5);
          return 0.4 + breathPhase * (1.4 - centerDistance * 1.5);
        }

        calculateRatioSequence(cellCount, columnIndex) {
          const ratios = [];

          for (let i = 0; i < cellCount; i++) {
            let ratio = 1.0;

            switch (this.params.ratioSystem) {
              case "fibonacci":
                const fibIndex = i % this.fibonacci.length;
                ratio = this.fibonacci[fibIndex] / 8;
                break;

              case "golden":
                const goldenIndex = i % this.golden.length;
                ratio = this.golden[goldenIndex] / 6;
                break;

              case "harmonic":
                ratio = (1 / (i + 1)) * 5;
                break;

              case "prime":
                const primeIndex = i % this.primes.length;
                ratio = this.primes[primeIndex] / 20;
                break;
            }

            // Apply variance scaling
            const minRatio = 1 / this.params.ratioVariance;
            const maxRatio = this.params.ratioVariance;
            ratio = minRatio + ratio * (maxRatio - minRatio);

            ratios.push(Math.max(0.2, Math.min(4.0, ratio)));
          }

          return ratios;
        }

        calculateConnectorTarget(cellId, cellHeight) {
          let connectorHeight = this.params.connectorSize;

          switch (this.params.connectorResponse) {
            case "flow":
              connectorHeight = Math.max(2, cellHeight * 0.12);
              break;

            case "inverse":
              connectorHeight = Math.max(
                2,
                this.params.connectorSize * (60 / cellHeight)
              );
              break;

            case "pulse":
              const pulsePhase =
                Math.sin(this.time * this.params.flowSpeed * 3) * 0.5 + 0.5;
              connectorHeight = this.params.connectorSize * (0.5 + pulsePhase);
              break;

            case "fixed":
            default:
              break;
          }

          return Math.max(1, Math.min(20, connectorHeight));
        }

        // RENDERING SYSTEM
        generateInitialState() {
          if (!this.params.isFlowing) {
            // Static mode - direct generation
            this.generateStaticGrid();
          }
        }

        generateStaticGrid() {
          this.renderedCells = [];
          this.renderedConnectors = [];

          const gridX = (this.canvas.width - this.params.frameWidth) / 2;
          const gridY = (this.canvas.height - this.params.frameHeight) / 2;
          const columnWidth = this.params.frameWidth / this.params.columns;

          for (let col = 0; col < this.params.columns; col++) {
            const density = this.calculateDensityFlow(col);
            const cellCount = Math.round(this.params.baseCells * density);
            const ratios = this.calculateRatioSequence(cellCount, col);

            const availableHeight = this.params.frameHeight * 0.85;
            const connectorSpace = this.params.connectorSize * (cellCount - 1);
            const cellSpace = availableHeight - connectorSpace;
            const totalRatio = ratios.reduce((sum, ratio) => sum + ratio, 0);

            const columnX = gridX + col * columnWidth;
            let currentY = gridY;

            for (let i = 0; i < cellCount; i++) {
              const cellHeight = (cellSpace * ratios[i]) / totalRatio;

              const cell = {
                columnIndex: col,
                rowIndex: i,
                x: columnX,
                y: currentY,
                width: columnWidth,
                height: Math.max(2, cellHeight),
                ratio: ratios[i],
              };

              this.renderedCells.push(cell);
              currentY += cell.height;

              // Add connector
              if (i < cellCount - 1) {
                const connectorHeight = this.calculateConnectorTarget(
                  `${col}-${i}`,
                  cell.height
                );
                const connector = {
                  columnIndex: col,
                  rowIndex: i,
                  x: columnX,
                  y: currentY,
                  width: columnWidth,
                  height: connectorHeight,
                };

                this.renderedConnectors.push(connector);
                currentY += connector.height;
              }
            }
          }
        }

        generateMorphologicalGrid() {
          this.renderedCells = [];
          this.renderedConnectors = [];

          const gridX = (this.canvas.width - this.params.frameWidth) / 2;
          const gridY = (this.canvas.height - this.params.frameHeight) / 2;
          const columnWidth = this.params.frameWidth / this.params.columns;

          for (let col = 0; col < this.params.columns; col++) {
            const columnState = this.morphState.columns.get(col);
            if (!columnState) continue;

            const cellCount = Math.round(columnState.cellCount);
            const columnX = gridX + col * columnWidth;
            let currentY = gridY;

            for (let i = 0; i < cellCount; i++) {
              const cellId = `${col}-${i}`;
              const cellState = this.morphState.cells.get(cellId);

              if (cellState && cellState.height > 1) {
                const cell = {
                  columnIndex: col,
                  rowIndex: i,
                  x: columnX,
                  y: currentY,
                  width: columnWidth,
                  height: cellState.height,
                  ratio: cellState.ratio,
                };

                this.renderedCells.push(cell);
                currentY += cell.height;

                // Add morphological connector
                if (i < cellCount - 1) {
                  const connectorId = `${col}-${i}-connector`;
                  const connectorState =
                    this.morphState.connectors.get(connectorId);

                  if (connectorState) {
                    const connector = {
                      columnIndex: col,
                      rowIndex: i,
                      x: columnX,
                      y: currentY,
                      width: columnWidth,
                      height: connectorState.height,
                    };

                    this.renderedConnectors.push(connector);
                    currentY += connector.height;
                  }
                }
              }
            }
          }
        }

        startMorphologicalLoop() {
          const animate = () => {
            if (this.params.isFlowing) {
              this.time += 0.016 * this.params.flowSpeed;
              this.updateMorphologicalTargets();
              this.generateMorphologicalGrid();
            } else {
              this.generateStaticGrid();
            }

            this.render();
            this.updateStats();
            this.animationFrame = requestAnimationFrame(animate);
          };

          animate();
        }

        render() {
          // Clear canvas
          this.ctx.fillStyle = "#ffffff";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          if (this.params.showGrid) {
            this.renderGridMode();
          } else {
            this.renderCleanMode();
          }

          this.renderBlueConnectors();
        }

        renderGridMode() {
          // Draw constraint frame
          const gridX = (this.canvas.width - this.params.frameWidth) / 2;
          const gridY = (this.canvas.height - this.params.frameHeight) / 2;

          this.ctx.strokeStyle = "#667eea";
          this.ctx.lineWidth = 2;
          this.ctx.setLineDash([8, 8]);
          this.ctx.beginPath();
          this.ctx.rect(
            gridX,
            gridY,
            this.params.frameWidth,
            this.params.frameHeight
          );
          this.ctx.stroke();
          this.ctx.setLineDash([]);

          // Column guides
          this.ctx.strokeStyle = "#e9ecef";
          this.ctx.lineWidth = 1;
          const columnWidth = this.params.frameWidth / this.params.columns;

          for (let col = 1; col < this.params.columns; col++) {
            const x = gridX + col * columnWidth;
            this.ctx.beginPath();
            this.ctx.moveTo(x, gridY);
            this.ctx.lineTo(x, gridY + this.params.frameHeight);
            this.ctx.stroke();
          }

          // Center guides with morphological indication
          this.ctx.strokeStyle = this.params.isFlowing ? "#764ba2" : "#f1f2f6";
          this.ctx.lineWidth = this.params.isFlowing ? 1 : 0.5;
          this.ctx.setLineDash([6, 6]);

          // Horizontal center
          this.ctx.beginPath();
          this.ctx.moveTo(gridX, gridY + this.params.frameHeight / 2);
          this.ctx.lineTo(
            gridX + this.params.frameWidth,
            gridY + this.params.frameHeight / 2
          );
          this.ctx.stroke();

          // Vertical center
          this.ctx.beginPath();
          this.ctx.moveTo(gridX + this.params.frameWidth / 2, gridY);
          this.ctx.lineTo(
            gridX + this.params.frameWidth / 2,
            gridY + this.params.frameHeight
          );
          this.ctx.stroke();

          this.ctx.setLineDash([]);

          // Render white space cells
          this.renderWhiteSpaceCells();
        }

        renderCleanMode() {
          // Pure morphological expression - only blue connectors visible
          return;
        }

        renderWhiteSpaceCells() {
          this.renderedCells.forEach((cell) => {
            // Cell fill with subtle morphological indication
            this.ctx.fillStyle = this.params.isFlowing ? "#fefefe" : "#ffffff";
            this.ctx.fillRect(cell.x, cell.y, cell.width, cell.height);

            // Cell boundary
            this.ctx.strokeStyle = this.params.isFlowing
              ? "#e3f2fd"
              : "#e9ecef";
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.rect(cell.x, cell.y, cell.width, cell.height);
            this.ctx.stroke();

            // Internal spacing with morphological awareness
            const spacing = Math.max(2, cell.height * 0.1);
            if (
              spacing > 4 &&
              cell.width > spacing * 2 &&
              cell.height > spacing * 2
            ) {
              const innerX = cell.x + spacing;
              const innerY = cell.y + spacing;
              const innerWidth = cell.width - spacing * 2;
              const innerHeight = cell.height - spacing * 2;

              this.ctx.fillStyle = this.params.isFlowing
                ? "#f3e5f5"
                : "#f8f9fa";
              this.ctx.fillRect(innerX, innerY, innerWidth, innerHeight);

              this.ctx.strokeStyle = this.params.isFlowing
                ? "#ce93d8"
                : "#dee2e6";
              this.ctx.lineWidth = 0.5;
              this.ctx.beginPath();
              this.ctx.rect(innerX, innerY, innerWidth, innerHeight);
              this.ctx.stroke();
            }
          });
        }

        renderBlueConnectors() {
          this.renderedConnectors.forEach((connector) => {
            // Enhanced connector with morphological flow indication
            if (this.params.isFlowing && connector.height > 4) {
              // Gradient for flow visualization
              const gradient = this.ctx.createLinearGradient(
                connector.x,
                connector.y,
                connector.x,
                connector.y + connector.height
              );
              gradient.addColorStop(0, "#0956FF");
              gradient.addColorStop(0.5, "#0956FF");
              gradient.addColorStop(1, "#0956FF");

              this.ctx.fillStyle = gradient;
            } else {
              this.ctx.fillStyle = "#0956FF";
            }

            this.ctx.fillRect(
              connector.x,
              connector.y,
              connector.width,
              connector.height
            );

            // Subtle glow effect for flowing state
            if (this.params.isFlowing && connector.height > 3) {
              this.ctx.shadowColor = "#0956FF";
              this.ctx.shadowBlur = 2;
              this.ctx.fillRect(
                connector.x,
                connector.y,
                connector.width,
                connector.height
              );
              this.ctx.shadowBlur = 0;
            }
          });
        }

        updateStats() {
          const statsElement = document.getElementById("stats");
          if (!statsElement) return; // Add null check

          const totalCells = this.renderedCells.length;
          const totalConnectors = this.renderedConnectors.length;
          const {
            columns,
            baseCells,
            frameWidth,
            frameHeight,
            ratioSystem,
            densityPattern,
          } = this.params;

          const flowState = this.params.isFlowing ? "Flowing" : "Static";
          const viewMode = this.params.showGrid ? "Grid" : "Clean";

          const statsText = `${flowState} ${viewMode}: ${columns}×${baseCells} | ${frameWidth}×${frameHeight} | ${totalCells} cells | ${ratioSystem}+${densityPattern}`;

          statsElement.textContent = statsText;
        }
      }

      // Global functions
      window.exportGrid = function () {
        const canvas = document.getElementById("canvas");
        if (!canvas) return; // Add null check

        const timestamp = new Date()
          .toISOString()
          .slice(0, 19)
          .replace(/:/g, "-");
        const mode = window.gridSystem.params.showGrid ? "grid" : "clean";
        const flowState = window.gridSystem.params.isFlowing
          ? "flowing"
          : "static";

        const link = document.createElement("a");
        link.download = `morphological-grid-${mode}-${flowState}-${timestamp}.png`;
        link.href = canvas.toDataURL();
        link.click();
      };

      // Initialize system
      document.addEventListener("DOMContentLoaded", () => {
        const canvas = document.getElementById("canvas");
        if (!canvas) {
          console.error("Canvas element not found!");
          return;
        }

        const gridSystem = new MorphologicalConstrainedGrid();
        window.gridSystem = gridSystem;

        // Enhanced keyboard shortcuts
        document.addEventListener("keydown", (e) => {
          switch (e.key.toLowerCase()) {
            case " ":
              e.preventDefault();
              const stillBtn = document.getElementById("stillMode");
              const flowBtn = document.getElementById("flowMode");
              if (stillBtn && flowBtn) {
                if (gridSystem.params.isFlowing) {
                  stillBtn.click();
                } else {
                  flowBtn.click();
                }
              }
              break;

            case "v":
              e.preventDefault();
              const gridBtn = document.getElementById("gridView");
              const cleanBtn = document.getElementById("cleanView");
              if (gridBtn && cleanBtn) {
                if (gridSystem.params.showGrid) {
                  cleanBtn.click();
                } else {
                  gridBtn.click();
                }
              }
              break;

            case "c":
              e.preventDefault();
              const toggleBtn = document.getElementById("toggleBtn");
              if (toggleBtn) {
                toggleBtn.click();
              }
              break;

            case "r":
              e.preventDefault();
              location.reload();
              break;

            case "e":
              e.preventDefault();
              if (window.exportGrid) {
                exportGrid();
              }
              break;
          }
        });

        // Development console utilities
        console.log("🌊 Morphological Constrained Grid System initialized");
        console.log(
          "🎯 Innovation: Wave interference movement with mathematical significance"
        );
        console.log(
          "⌨️  Controls: Space=flow, V=view, C=controls, E=export, R=reset"
        );
        console.log(
          "🏗️  Architecture: Velocity-based morphology within fixed boundaries"
        );
        console.log("🎨 Clean Mode: Pure mathematical flow visualization");
        console.log(
          "🌀 Wave System: Golden ratio + Fibonacci + Prime interference"
        );

        // Development helpers
        window.dumpMorphState = () => {
          console.log("Morphological State:");
          console.log("Cells:", gridSystem.morphState.cells);
          console.log("Columns:", gridSystem.morphState.columns);
          console.log("Connectors:", gridSystem.morphState.connectors);
        };

        window.triggerMorphUpdate = () => {
          gridSystem.scheduleMorphologicalUpdate();
          console.log("Morphological update triggered");
        };

        window.inspectWaveSystem = () => {
          const time = gridSystem.time;
          console.log("Wave Interference Analysis:");
          for (let col = 0; col < gridSystem.params.columns; col++) {
            const normalizedPos =
              col / Math.max(1, gridSystem.params.columns - 1);
            const density = gridSystem.calculateWaveInterference(
              normalizedPos,
              time
            );
            console.log(
              `Column ${col}: pos=${normalizedPos.toFixed(
                3
              )}, density=${density.toFixed(3)}`
            );
          }
        };

        window.addNewMovementSystem = (name, systemFunction) => {
          gridSystem.movementSystems[name] = systemFunction.bind(gridSystem);
          console.log(`Added new movement system: ${name}`);
        };
      });
    </script>
  </body>
</html>
